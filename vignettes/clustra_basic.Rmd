---
title: "clustra-basic"
author: "George Ostrouchov"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{clustra-basic}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```
The \pkg{clustra} package was built to cluster medical trajectories related by an intervention. For example, a number of individuals are started on a specific drug regimen and their blood pressure data is collected for a varying amount of time before and after the start of the medication. Time is recorded as negative before the start and positive after the start, meaning that the trajectories are aligned at zero, irrespective of any reference to calendar time. Time units can be anything (days, weeks, hours, minutes, etc.) as long as they are the same across all patients. Observations do not have to be equally spaced.

First, we load the package and set up a directory where we want to have any output from this vignette.
```{r setup}
library(clustra)

## Set working directory
playdir = "~/clustra_play"
if(!dir.exists(playdir)) dir.create(playdir)
```
In this vignette, we generate a data set. The parameters used in the data generation can be examined by looking at `clustra_env("gen")` function return.
```{r}
clustra_env("gen")
```
The above default parameters generate `r clustra_env("gen$n_id")` *id*s and for each *id*, a random number of observations based on the Poisson($\lambda =$ `r clustra_env("gen$m_obs")`) distribution plus 3. The 3 additional observations are to guarantee one before intervention at time *start*, one at the intervention time 0, and one after the intervention at time *end*. The *start* time is Uniform(`r clustra_env("gen$s_range")`) and the *end* time is Uniform(`r clustra_env("gen$e_range")`). The remaining times are at times Uniform(*start*, *end*). The time units are arbitrary and depend on your application.

We also set a seed for reproducibility.
```{r}
set.seed(clustra_env("gen$seed"))
## Generate a data set
data = gen_traj_data()
head(data)
write.table(data, file = "clustra_gen_data.csv")
```
Select a few random *id*s and print their scatterplots.
```{r fig.width = 7, fig.height = 9}
library(ggplot2)
iplot = sample(unique(data$id), 9)
sampobs = match(data$id, iplot, nomatch = 0) > 0
ggplot(data[sampobs, ], aes(x = time, y = response)) +
  facet_wrap(~ id) + geom_point()
```
Now cluster the trajectories. Set maximum iterations to 10, set cluster seed for reproducibility. \code{cor} parameters set the number of cores to use in \code{mclapply} components of the code to do model fits for different clusters in parallel on different cores. Note that this does not work on Windows platforms, where it should be left at 1.
```{r}
clustra_env("clu$iter = 10", "clu$seed = 123473",
            "cor$e_mc = 1", "cor$m_mc = 1")
rng_prev = RNGkind(clustra_env("clu$rngkind"))
set.seed(clustra_env("clu$seed"))
cl = clustra(data, 3, verbose = TRUE)
```

```{r fig.width = 7, fig.height = 7}
plot(mgcViz::getViz(cl$tps))
```
Average silhouette value is a way to select the number of clusters and a silhouette plot provides a way for a deeper evaluation (Rouseeuw 1986). As silhouette requires distances between trajectories, this is not possible due to unequal tranectory sampling without fitting a model. As a proxy for distance between points, we consider point distances to cluster means. The structure return from clustra contains the matrix *loss*, which has all the information to construct the proxy silhouette plot.
```{r fig.width = 7}
sil = clustra_sil(data, verbose = TRUE)
## TODO add sampling option if too many ids
splots = lapply(sil, function(x) print(factoextra::fviz_silhouette(x)))
```

```{r}
clustra_env("ran")
```
Rand Index to compares pairs of random starts. When replicate clusterings are done with different random seeds, their "replicability" is an indicator of how stable are results for a given k, the number of clusters. For this demonstration, we look at k = 2, 3, 4, and only five replications for each k. We use the clustra_env() function to set these parameters before running RandIndex_pairs().
```{r}
clustra_env("ran$ng_vec = c(2, 3, 4)", "ran$replicates = 5", "clu$iter = 4")
```
Finally, we plot the resulting matrix of Rand Indices.
```{r fig.width = 8, fig.height=9}
ran = clustra_rand(data, verbose = TRUE)
rand_plot(ran)

## restore RNG
RNGkind(rng_prev[1])
```